\thispagestyle{appendixheader}
\stepcounter{app}
\setcounter{app_fig}{1}
\setcounter{app_tab}{1}
\setcounter{equation}{0}
\renewcommand\theequation{附\arabic{app}-\arabic{equation}}
% \renewcommand\theequation{\Alph{app}.\arabic{equation}}
\renewcommand\chaptername{附录}
\renewcommand\chaptername{Appendix} 
\renewcommand\thechapter{附录\zhnum{app}} 

\setcounter{chapter}{0}
\setcounter{section}{0}
\chapter{优化方案的python实现}\label{chap:app1}{
在\ref{sec-optimize}节中介绍了对基于TDD的量子模型检测的一些优化方案。
本附录是关于这些优化方法的具体实现，以python为例。

首先是
\begin{lstlisting}[language=Python, caption=Python example]
def image(qa):
    sp= generate_initial_space(qa.initial_states)
    max_node = 0
    for op in qa.operators:
        qa.operators[op],node = qa.operators[op].cont()
        max_node = max(max_node,node)
    res_list = []
    for op in qa.operators:
        for phi in qa.initial_states:
            max_node= max(max_node,qa.operators[op].node_number())
            res=simulation(qa.operators[op],phi)
            res_list.append(res)
            change_index(res,'y','x')
            max_node = max(max_node,res.node_number())
            sp,_=join(sp,res)
    return sp,max_node
\end{lstlisting}
\section*{addition优化方案}
\begin{lstlisting}[language=Python, caption=对量子电路应用addition优化方案]
def image_add_par(tn,qa,k=0,partial=0):
    sp= generate_initial_space(qa.initial_states)

    if not partial:
        for op in qa.operators:
            qa.operators[op]=addition_partition(tn,k)
    else:
        for op in qa.operators:
            qa.operators[op]=addition_partition_partial(tn,k)

    for op in qa.operators:
        for phi in qa.initial_states:
            res=get_identity_tdd()
            res.weight=0
            for p in qa.operators[op]:
                temp=simulation(p,phi)
                change_index(temp,'y','x')
                res=add(res,temp)
            update_tdd_after_add(res,temp)
            sp,_=join(sp,res)

    return sp
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=对量子电路应用contraction优化方案]
def image_cont_par(qa,k1=0,k2=0):
    sp= generate_initial_space(qa.initial_states)
    max_node = 0
    for op in qa.operators:
        qa.operators[op],node=contraction_partition(qa.operators[op],k1,k2)
        max_node = max(node,max_node)

    res_list=[]
    for op in qa.operators:
        for phi in qa.initial_states:
            res=phi
            for p in qa.operators[op]:
                max_node = max(max_node,p.node_number())
                res=simulation(p,res)
                max_node = max(max_node,res.node_number())
            change_index(res,'y','x')
            res_list.append(res)
            sp,_=join(sp,res)
    return sp,max_node
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=对TDD运用窗函数划分]
def tdd_partition(tdd: TDD, windows: list[dict]) -> list[TDD]:
    if not check_windows(windows):
        return []

    partitions = [partition(tdd.node, window) for window in windows]
    for partitioned_tdd in partitions:
        G.tdd_initial(partitioned_tdd,tdd)
        if partitioned_tdd.weight:
            partitioned_tdd.weight = tdd.weight

    return partitions
\end{lstlisting}
\begin{lstlisting}[language=Python, caption=对TDD进行分割]
def tdd_split(tdd:TDD, split_point:int)-> list[TDD,TDD]:
    B= split_before(tdd.node, split_point)
    A= split_after(tdd.node, split_point)
    return generate_tdd_index(B, A, tdd, split_point)
\end{lstlisting}
\thispagestyle{appendixheader}
}