@ARTICLE{initial,title={Automatic Uniform Quantum State Preparation Using Decision Diagrams},year={2020},author={Fereshte Mozafari and Mathias Soeken and Heinz Riener and Heinz Riener and Giovanni De Micheli},doi={10.1109/ismvl49045.2020.00-10},pmid={null},pmcid={null},mag_id={3119415292},journal={2020 IEEE 50th International Symposium on Multiple-Valued Logic (ISMVL)},abstract={Most quantum algorithms assume some specific initial state in superposition of basis states before performing the desired application-specific computations. The preparation of such states itself requires a computation performed by a quantum circuit. In this paper, we investigate the automatic state preparation of a specific subset of quantum states that are uniform superpositions over a subset of basis states, called uniform quantum states. We exploit that such states can be represented using Boolean functions and present a recursive algorithm based on functional decomposition. When using binary decision diagrams as function representation, we can enable fast and scalable quantum state preparation with respect to the size of the decision diagram. We show that the algorithm can find quantum circuits for functions, where state-of-the-art algorithms cannot be applied anymore.}}
@ARTICLE{example,title={From Boolean functions to quantum circuits: A scalable quantum compilation flow in C++},year={2021},author={Bruno Schmitt and Fereshte Mozafari and Giulia Meuli and Heinz Riener and Giovanni De Micheli},doi={10.23919/date51398.2021.9474237},pmid={null},pmcid={null},mag_id={3184664169},journal={2021 Design, Automation & Test in Europe Conference & Exhibition (DATE)},abstract={We propose a flow for automated quantum compilation. Our flow takes a Boolean function implemented in Python as input and translates it into a format appropriate for reversible logic synthesis. We focus on two quantum compilation tasks: uniform state preparation and oracle synthesis. To illustrate the use of our flow, we solve IBM's virtual hackathon challenge of 2019, called the Zed city problem, an instance of vertex coloring, by using quantum search algorithms. The expressiveness of Python in combination with automated compilation algorithms allows us to express quantum algorithms at a high level of abstraction, which reduces the effort to implement them, and leads to better and more flexible implementations. We show that our proposed flow generates a lower-cost circuit implementation of the oracle needed to solve IBM's challenge when compared to the winning submission.}}
@ARTICLE{Tweedledum,title={Tweedledum: A Compiler Companion for Quantum Computing},year={2022},author={Bruno Schmitt and Giovanni De Micheli},doi={10.23919/date54114.2022.9774510},pmid={null},pmcid={null},mag_id={4280636891},journal={2022 Design, Automation & Test in Europe Conference & Exhibition (DATE)},abstract={This work presents tweedledum-an extensible open-source library aiming at narrowing the gap between high-level algorithms and physical devices by enhancing the expressive power of existing frameworks. For example, it allows designers to insert classical logic (defined at a high abstraction level, e.g., a Python function) directly into quantum circuits. We describe its design principles, concrete implementation, and, in particular, the library's core: An intuitive and flexible intermediate representation (IR) that supports different abstraction levels across the same circuit structure.}}
@ARTICLE{EPFL,title={The EPFL Logic Synthesis Libraries.},year={2018},author={Mathias Soeken and Heinz Riener and Winston Haaswijk and Giovanni De Micheli},doi={null},pmid={null},pmcid={null},mag_id={2800719180},journal={arXiv: Logic in Computer Science},abstract={We present a collection of modular open source C++ libraries for the development of logic synthesis applications. The alice library is a lightweight wrapper for shell interfaces, which is the typical user interface for most logic synthesis and design automation applications. It includes a Python interface to support scripting. The lorina library is a parsing library for simple file formats commonly used in logic synthesis. It includes several customizable parsing algorithms and a flexible diagnostic engine. The kitty library is a truth table library for explicit representation and manipulation of Boolean functions. It requires less overhead compared to symbolic counterparts such as binary decision diagrams, but is limited by the number of variables of the Boolean function to represent. Finally, percy is an exact synthesis library with multiple engines to find optimum logic networks. All libraries are well documented and well tested. Furthermore, being header-only, the libraries can be readily used as core components in complex logic synthesis systems.}}



@ARTICLE{multiplicative,title={The Role of Multiplicative Complexity in Compiling Low T-count Oracle Circuits},year={2019},author={Giulia Meuli and Mathias Soeken and Earl T. Campbell and Martin Roetteler and Giovanni De Micheli},doi={10.1109/iccad45719.2019.8942093},pmid={null},pmcid={null},mag_id={2964777125},journal={arXiv: Quantum Physics},abstract={We present a constructive method to create quantum circuits that implement oracles $|x\rangle|y\rangle|0\rangle^k \mapsto |x\rangle|y \oplus f(x)\rangle|0\rangle^k$ for $n$-variable Boolean functions $f$ with low $T$-count. In our method $f$ is given as a 2-regular Boolean logic network over the gate basis $\{\land, \oplus, 1\}$. Our construction leads to circuits with a $T$-count that is at most four times the number of AND nodes in the network. In addition, we propose a SAT-based method that allows us to trade qubits for $T$ gates, and explore the space/complexity trade-off of quantum circuits. Our constructive method suggests a new upper bound for the number of $T$ gates and ancilla qubits based on the multiplicative complexity $c_\land(f)$ of the oracle function $f$, which is the minimum number of AND gates that is required to realize $f$ over the gate basis $\{\land, \oplus, 1\}$. There exists a quantum circuit computing $f$ with at most $4 c_\land(f)$ $T$ gates using $k = c_\land(f)$ ancillae. Results known for the multiplicative complexity of Boolean functions can be transferred. We verify our method by comparing it to different state-of-the-art compilers. Finally, we present our synthesis results for Boolean functions used in quantum cryptoanalysis.}}
